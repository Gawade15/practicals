//dfs bfs
#include <iostream>
#include <vector>
#include <queue>
#include <omp.h>

using namespace std;

class Graph {
private:
    int V;
    vector<vector<int>> adj;

public:
    Graph(int V) {
        this->V = V;
        adj.resize(V);
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u); // For undirected graph
    }

    void bfs(int source) {
        vector<bool> visited(V, false);
        queue<int> q;

        q.push(source);
        visited[source] = true;

        while (!q.empty()) {
            int u = q.front();
            q.pop();
            cout << u << " ";

            #pragma omp parallel for
            for (int i = 0; i < adj[u].size(); ++i) {
                int v = adj[u][i];
                if (!visited[v]) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
    }

    void dfsUtil(int u, vector<bool>& visited) {
        visited[u] = true;
        cout << u << " ";

        #pragma omp parallel for
        for (int i = 0; i < adj[u].size(); ++i) {
            int v = adj[u][i];
            if (!visited[v]) {
                dfsUtil(v, visited);
            }
        }
    }

    void dfs(int source) {
        vector<bool> visited(V, false);
        dfsUtil(source, visited);
    }
};

int main() {
    Graph g(6);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 5);

    cout << "BFS traversal: ";
    g.bfs(0);
    cout << endl;

    cout << "DFS traversal: ";
    g.dfs(0);
    cout << endl;

    return 0;
}




//min max


#include <iostream>
//#include <vector>
#include <omp.h>
#include <climits>
using namespace std;
void min_reduction(int arr[], int n) {
  int min_value = INT_MAX;
  #pragma omp parallel for reduction(min: min_value)
  for (int i = 0; i < n; i++) {
	if (arr[i] < min_value) {
  	min_value = arr[i];
	}
  }
  cout << "Minimum value: " << min_value << endl;
}

void max_reduction(int arr[], int n) {
  int max_value = INT_MIN;
  #pragma omp parallel for reduction(max: max_value)
  for (int i = 0; i < n; i++) {
	if (arr[i] > max_value) {
  	max_value = arr[i];
	}
  }
  cout << "Maximum value: " << max_value << endl;
}

void sum_reduction(int arr[], int n) {
  int sum = 0;
   #pragma omp parallel for reduction(+: sum)
   for (int i = 0; i < n; i++) {
	sum += arr[i];
  }
  cout << "Sum: " << sum << endl;
}

void average_reduction(int arr[], int n) {
  int sum = 0;
  #pragma omp parallel for reduction(+: sum)
  for (int i = 0; i < n; i++) {
	sum += arr[i];
  }
  cout << "Average: " << (double)sum / (n-1) << endl;
}

int main() {
    int *arr,n;
    cout<<"\n enter total no of elements=>";
    cin>>n;
    arr=new int[n];
    cout<<"\n enter elements=>";
    for(int i=0;i<n;i++)
    {
   	 cin>>arr[i];
    }

//   int arr[] = {5, 2, 9, 1, 7, 6, 8, 3, 4};
//   int n = size(arr);

  min_reduction(arr, n);
  max_reduction(arr, n);
  sum_reduction(arr, n);
  average_reduction(arr, n);
}



//bubble sort ,merge sort

#include <iostream>
#include <vector>
#include <omp.h>
#include <chrono>
#include <algorithm>

using namespace std;
using namespace std::chrono;


void sequentialBubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

void parallelBubbleSort(vector<int>& arr) {
    int n = arr.size();
    bool swapped;
    #pragma omp parallel
    {
        do {
            swapped = false;
            #pragma omp for
            for (int i = 0; i < n - 1; ++i) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr[i], arr[i + 1]);
                    swapped = true;
                }
            }
        } while (swapped);
    }
}

void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    vector<int> L(n1), R(n2);

    for (int i = 0; i < n1; ++i) {
        L[i] = arr[left + i];
    }

    for (int j = 0; j < n2; ++j) {
        R[j] = arr[mid + 1 + j];
    }

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }

    while (i < n1) {
        arr[k++] = L[i++];
    }

    while (j < n2) {
        arr[k++] = R[j++];
    }
}

void sequentialMergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        sequentialMergeSort(arr, left, mid);
        sequentialMergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

void parallelMergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        #pragma omp parallel sections
        {
            #pragma omp section
            parallelMergeSort(arr, left, mid);
            #pragma omp section
            parallelMergeSort(arr, mid + 1, right);
        }
        merge(arr, left, mid, right);
    }
}

// Main Function
int main() {
    int n = 10000; // Change the array size as needed
    vector<int> arr(n);

    // Initialize array with random values
    srand(time(0));
    for (int i = 0; i < n; ++i) {
        arr[i] = rand() % 10000;
    }

    // Measure time for Sequential Bubble Sort
    auto start = high_resolution_clock::now();
     parallelBubbleSort(arr);
    //sequentialBubbleSort(arr);
    auto stop = high_resolution_clock::now();
    auto durationSequentialBubbleSort = duration_cast<milliseconds>(stop - start);

    // Measure time for Parallel Bubble Sort
    start = high_resolution_clock::now();
    //parallelBubbleSort(arr);
    sequentialBubbleSort(arr);
    stop = high_resolution_clock::now();
    auto durationParallelBubbleSort = duration_cast<milliseconds>(stop - start);

    // Reset array for merge sort
    for (int i = 0; i < n; ++i) {
        arr[i] = rand() % 10000;
    }

    // Measure time for Sequential Merge Sort
    start = high_resolution_clock::now();
    sequentialMergeSort(arr, 0, n - 1);
    stop = high_resolution_clock::now();
    auto durationSequentialMergeSort = duration_cast<milliseconds>(stop - start);

    // Measure time for Parallel Merge Sort
    start = high_resolution_clock::now();
    parallelMergeSort(arr, 0, n - 1);
    stop = high_resolution_clock::now();
    auto durationParallelMergeSort = duration_cast<milliseconds>(stop - start);

    // Display execution times
    cout << "Sequential Bubble Sort Time: " << durationSequentialBubbleSort.count() << " milliseconds" << endl;
    cout << "Parallel Bubble Sort Time: " << durationParallelBubbleSort.count() << " milliseconds" << endl;
    cout << "Sequential Merge Sort Time: " << durationSequentialMergeSort.count() << " milliseconds" << endl;
    cout << "Parallel Merge Sort Time: " << durationParallelMergeSort.count() << " milliseconds" << endl;

    return 0;
}


